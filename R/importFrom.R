
# library(devtools)
#
# debugonce(roxygen2:::parse_package)
# debugonce(roxygen2:::tokenize_file)
# devtools::document()
#


#' because base::parseNamespaceFile() is not very handy
parse_namespace = function(file){
  test_file = getOption("test_file")
  if(!is.null(test_file)) file = test_file
  rtn = read_lines(file) %>%
    as_tibble() %>%
    filter(value!="" & value!="# Generated by roxygen2: do not edit by hand") %>%
    separate_wider_regex(value, patterns=c(operator=".+", "\\(", value=".+", "\\)")) %>%
    split(.$operator)

  rtn$importFrom = rtn$importFrom %>%
    separate_wider_delim(value, names=c("from", "what"), delim=",")
  # rtn$import = rtn$import %>%
  #   rename(from=value)
  rtn
}


#' @param ref a ref
#' @param pkg_name package name (character)
#' @param ns result of `parse_namespace()`
#' @noRd
parse_ref = function(ref, pkg_name, ns, deps){
  .fun = paste(as.character(ref, useSource=TRUE), collapse="\n")
  pd = getParseData(parse(text=.fun))
  non_comment = pd %>% filter(token!="COMMENT") %>% pull(text) %>% paste(collapse="")
  nms = pd$text[pd$token == "SYMBOL_FUNCTION_CALL"]
  if(length(nms)==0) return(NULL)

  loc = nms %>%
    as_tibble_col(column_name="fun") %>%
    mutate(pkg = map(fun, ~get_anywhere(.x, prefer=c(pkg_name, ".GlobalEnv")))) %>%
    unchop(pkg, keep_empty=TRUE) %>%
    mutate(
      label = ifelse(is.na(pkg), NA, paste(pkg, fun, sep="::")),
      pkg_in_desc = pkg %in% deps$package,
      pkg_n_imports = map_int(pkg, ~sum(ns$importFrom$from==.x)),
      # fun_internal = map2_lgl(pkg, fun, ~{any(ns$importFrom$what==.y)}),
      fun_imported = map2_lgl(pkg, fun, ~{any(ns$importFrom$what==.y)}),
      fun_imported2 = map2_lgl(pkg, fun, ~{any(ns$importFrom$from==.x & ns$importFrom$what==.y)}),
    ) %>%
    distinct() %>%
    arrange(fun, desc(fun_imported), desc(pkg_n_imports), pkg_in_desc)
  # browser()
  # loc = nms %>%
  #   as_tibble_col(column_name="fun") %>%
  #   mutate(pkg = map(fun, ~getAnywhere(.x)$where)) %>%
  #   unchop(pkg, keep_empty=TRUE) %>%
  #   mutate(
  #     pkg = str_remove(pkg, "package:|namespace:"),
  #     label = ifelse(is.na(pkg), NA, paste(pkg, fun, sep="::")),
  #     pkg_in_desc = pkg %in% deps$package,
  #     fun_imported = map2_lgl(pkg, fun, ~{any(ns$importFrom$from==.x & ns$importFrom$what==.y)}),
  #     pkg_n_imports = map_int(pkg, ~sum(ns$importFrom$from==.x)),
  #   ) %>%
  #   distinct() %>%
  #   arrange(fun, desc(fun_imported), desc(pkg_n_imports), pkg_in_desc)
  loc
}

# empty_ref = getSrcref(parse(text="c(1)", keep.source=TRUE)) %>% list_importFrom() %>% .[[1]] %>% .[0,]
# dput(empty_ref)
empty_ref = structure(list(fun = character(0), pkg = list(), pkg_str = character(0),
                           action = character(0), reason = character(0), pkgs = list()),
                      row.names = integer(0), class = "data.frame")

parse_function = function(ref, pkg_name, ns, deps){
  loc = parse_ref(ref, pkg_name, ns, deps)
  # if(is.null(loc)) browser()
  if(is.null(loc)) return(empty_ref)
  if(nrow(loc)==0) return(loc)
  # .x=loc %>% filter(fun=="stop")
  # browser()
  rslt = loc %>%
    split(.$fun) %>%
    imap(~{
      rtn = list(.x$pkg)
      action = "nothing"
      # if(.y=="get_inserts") browser()
      if(nrow(.x)==1) {
        if(is.na(.x$pkg)) {
          action = "warn"
          reason = glue("`{.y}()` not found in any loaded package.")
        } else if(.x$pkg==pkg_name) {
          reason = glue("`{.x$fun}()` is internal to {pkg_name}")
        } else if(.x$pkg=="base") {
          reason = glue("`{.x$fun}()` is base R")
        } else if(isTRUE(.x$fun_imported)) {
          reason = glue("`{.x$label}()` is unique and already imported.")
        # } else if(isFALSE(.x$pkg_in_desc)) {
        #   action = "add_description"
        #   reason = glue("`{.y}()` only found in package `{.x$pkg}`,
        #                     but your should add it to DESCRIPTION first.")
        } else {
          action = "add_pkg"
          reason = glue("`{.y}()` only found in package `{.x$pkg}`.")
        }

      } else {
        imported = .x %>% filter(fun_imported)
        base = .x %>% filter(pkg=="base")

        if(nrow(imported)>1) {
          dups = .x %>% filter(fun_imported) %>% pull(label)
          cli_abort(c("duplicate in NAMESPACE??", i="Functions: {.fun {dups}}"))
        } else if(nrow(imported)==1){
          rtn = list(imported$pkg)
          reason = glue("`{imported$label}()` already imported.")
        # } else if(nrow(base)>0){
        #   stopifnot(nrow(base)==1)
        #   rtn = list(base$pkg)
        #   reason = glue("`base::{.y}()` preferred")
        } else {
          action = "ask_user"
          reason = "Multiple choices"
        }
      }
      tibble(fun=.y, pkg=rtn, action=action, reason=reason, pkgs=list(.x))
    }) %>%
    list_rbind() %>%
    mutate(pkg_str = map_chr(pkg, paste, collapse="/"), .after=pkg) %>%
    arrange(action)
}

list_importFrom = function(refs, pkg_name, ns, deps, verbose=FALSE){
  rslt = refs %>%
    imap(~{
      if(verbose){
        if(str_starts(.y, "unnamed_")){
          cli_inform(c(i="Parsing code block {.code {.y}}"))
        } else {
          cli_inform(c(i="Parsing function {.fun {.y}}"))
        }
      }
      parse_function(.x, pkg_name=pkg_name, ns=ns, deps=deps)
    })
  rslt
}


get_inserts = function(.x, user_choice, exclude){
  if(is.null(.x)) return(NULL)
  if(nrow(.x)==0) return(NULL)
  .x %>%
    mutate(
      tmp = user_choice[fun] %>% modify_if(is.null, ~"error"),
      pkg = if_else(lengths(pkg)>1, tmp, pkg) %>% unlist()) %>%
    group_by(pkg) %>%
    summarise(label = paste(cur_group(), paste(sort(fun), collapse=" "))) %>%
    filter(!is.na(pkg) & !pkg %in% exclude) %>%
    pull(label)
}

get_lines2 = function(src_ref, imports){
  # browser()
  # if(.y=="unnamed_1") browser()
  # if(is.null(imports)) return(character(0))
  insert = glue("#' @importFrom {imports}")
  fun_c = as.character(src_ref)
  # if(fun_c[4]=="dplyr::`%>%`") browser()
  #
  # cli_inform("{last(fun_c)} -> is_reexport={is_reexport(fun_c)}")

  if(is_reexport(fun_c)){
    #TODO improve reexport management
    return(fun_c)
  }

  rmv = str_starts(fun_c, "#+' *@importFrom")
  if(any(rmv)){
    pos = min(which(rmv))
    fun_c = fun_c[!rmv]
  } else {
    x = parse(text=fun_c, keep.source=TRUE) %>% get_srcref_lines()
    stopifnot(length(x)==1)
    pos = x[[1]]$first_line_fun
  }
  insert_line(fun_c, insert, pos=pos)
}

is_reexport = function(fun_c){
  last_call = last(fun_c)
  str_detect(last_call, "(\\w+):{1,3}(?!:)(.+)") &&
    !str_detect(last_call, "(^|\\W)function\\(")
}

