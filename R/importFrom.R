
# library(devtools)
#
# debugonce(roxygen2:::parse_package)
# debugonce(roxygen2:::tokenize_file)
# devtools::document()
#


#' because base::parseNamespaceFile() is not very handy
parse_namespace = function(file="./NAMESPACE"){
  test_file = getOption("test_file")
  if(!is.null(test_file)) file = test_file
  rtn = read_lines(file) %>%
    as_tibble() %>%
    filter(value!="" & value!="# Generated by roxygen2: do not edit by hand") %>%
    separate_wider_regex(value, patterns=c(operator=".+", "\\(", value=".+", "\\)")) %>%
    split(.$operator)

  rtn$importFrom = rtn$importFrom %>%
    separate_wider_delim(value, names=c("from", "what"), delim=",")
  # rtn$import = rtn$import %>%
  #   rename(from=value)
  rtn
}

parse_ref = function(ref){
  .fun = paste(as.character(ref, useSource=TRUE), collapse="\n")
  pd = getParseData(parse(text=.fun))
  non_comment = pd %>% filter(token!="COMMENT") %>% pull(text) %>% paste(collapse="")
  # fun_name = str_extract(non_comment, regex("(.*?) *(?:=|<-) *function.*"), group=TRUE)
  nms = pd$text[pd$token == "SYMBOL_FUNCTION_CALL"]
  if(length(nms)==0) return(NULL)
  deps = desc::desc()$get_deps()
  ns = parse_namespace()

  loc = nms %>%
    as_tibble_col(column_name="fun") %>%
    mutate(pkg = map(fun, ~get_anywhere(.x))) %>% 
    unchop(pkg, keep_empty=TRUE) %>%
    mutate(
      label = ifelse(is.na(pkg), NA, paste(pkg, fun, sep="::")),
      pkg_in_desc = pkg %in% deps$package,
      pkg_n_imports = map_int(pkg, ~sum(ns$importFrom$from==.x)),
      fun_imported = map2_lgl(pkg, fun, ~{any(ns$importFrom$what==.y)}),
      fun_imported2 = map2_lgl(pkg, fun, ~{any(ns$importFrom$from==.x & ns$importFrom$what==.y)}),
    ) %>%
    distinct() %>%
    arrange(fun, desc(fun_imported), desc(pkg_n_imports), pkg_in_desc)
    
  # loc = nms %>%
  #   as_tibble_col(column_name="fun") %>%
  #   mutate(pkg = map(fun, ~getAnywhere(.x)$where)) %>%
  #   unchop(pkg, keep_empty=TRUE) %>%
  #   mutate(
  #     pkg = str_remove(pkg, "package:|namespace:"),
  #     label = ifelse(is.na(pkg), NA, paste(pkg, fun, sep="::")),
  #     pkg_in_desc = pkg %in% deps$package,
  #     fun_imported = map2_lgl(pkg, fun, ~{any(ns$importFrom$from==.x & ns$importFrom$what==.y)}),
  #     pkg_n_imports = map_int(pkg, ~sum(ns$importFrom$from==.x)),
  #   ) %>%
  #   distinct() %>%
  #   arrange(fun, desc(fun_imported), desc(pkg_n_imports), pkg_in_desc)
  loc
}

# empty_ref = getSrcref(parse(text="c(1)", keep.source=TRUE)) %>% list_importFrom() %>% .[[1]] %>% .[0,]
# dput(empty_ref)
empty_ref = structure(list(fun = character(0), pkg = list(), pkg_str = character(0), 
                           action = character(0), reason = character(0), pkgs = list()), 
                      row.names = integer(0), class = "data.frame")

parse_function = function(ref, this_pkg){
  loc = parse_ref(ref)
  # if(is.null(loc)) browser()
  if(is.null(loc)) return(empty_ref)
  if(nrow(loc)==0) return(loc)
  # .x=loc %>% filter(fun=="stop")
  # browser()
  rslt = loc %>%
    split(.$fun) %>% 
    imap(~{
      rtn = list(.x$pkg)
      action = "nothing"

      if(nrow(.x)==1) {
        if(is.na(.x$pkg)) {
          action = "warn"
          reason = glue("`{.y}()` not found in any loaded package.")
        } else if(.x$pkg==this_pkg$package) {
          reason = glue("`{.x$label}()` in internal to {this_pkg$package}")
        } else if(.x$pkg=="base") {
          reason = glue("`{.x$label}()` in base R")
        } else if(isTRUE(.x$fun_imported)) {
          reason = glue("`{.x$label}()` unique and already imported.")
        # } else if(isFALSE(.x$pkg_in_desc)) {
        #   action = "add_description"
        #   reason = glue("`{.y}()` only found in package `{.x$pkg}`,
        #                     but your should add it to DESCRIPTION first.")
        } else {
          action = "add_pkg"
          reason = glue("`{.y}()` only found in package `{.x$pkg}`.")
        }

      } else {
        imported = .x %>% filter(fun_imported)
        base = .x %>% filter(pkg=="base")

        if(nrow(imported)>1) {
          dups = .x %>% filter(fun_imported) %>% pull(label)
          cli_abort(c("duplicate in NAMESPACE??", i="Functions: {.fun {dups}}"))
        } else if(nrow(imported)==1){
          rtn = list(imported$pkg)
          reason = glue("`{imported$label}()` already imported.")
        # } else if(nrow(base)>0){
        #   stopifnot(nrow(base)==1)
        #   rtn = list(base$pkg)
        #   reason = glue("`base::{.y}()` preferred")
        } else {
          action = "ask_user"
          reason = "Multiple choices"
        }
      }
      tibble(fun=.y, pkg=rtn, action=action, reason=reason, pkgs=list(.x))
    }) %>%
    list_rbind() %>%
    mutate(pkg_str = map_chr(pkg, paste, collapse="/"), .after=pkg) %>%
    arrange(action)
}

list_importFrom = function(refs, this_pkg=NULL, verbose=FALSE){
  this_pkg = get_package(this_pkg)
  rslt = refs %>%
    imap(~{
      if(verbose){
        if(str_starts(.y, "unnamed_")){
          cli_inform(c(i="Parsing code block {.code {.y}}"))
        } else {
          cli_inform(c(i="Parsing function {.fun {.y}}"))
        }
      }
      parse_function(.x, this_pkg=this_pkg)
    })
  rslt
}


get_inserts = function(.x){
  if(is.null(.x)) return(NULL)
  if(nrow(.x)==0) return(NULL)
  .x %>% 
    mutate(
      tmp = user_choice[fun] %>% modify_if(is.null, ~"error"), 
      pkg = if_else(lengths(pkg)>1, tmp, pkg) %>% unlist()) %>% 
    group_by(pkg) %>% 
    summarise(label = paste(cur_group(), paste(sort(fun), collapse=" "))) %>% 
    filter(!is.na(pkg) & pkg!="base") %>% 
    pull(label)
}

get_lines2 = function(inserts, .x, .y){
  # browser()
  # if(is.null(inserts[[.y]])) return(character(0))
  insert = glue("#' @importFrom {inserts[[.y]]}")
  fun_c = as.character(.x)
  rmv = str_starts(fun_c, "#+' *@importFrom")
  if(any(rmv)){
    pos = min(which(rmv))
    fun_c = fun_c[!rmv]
  } else {
    x = parse(text=fun_c, keep.source=TRUE) %>% get_srcref_lines()
    stopifnot(length(x)==1)
    pos = x[[1]]$first_line_fun
  }
  insert_line(fun_c, insert, pos=pos)
}